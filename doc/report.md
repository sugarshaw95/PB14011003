## MP1

* 总述

  mp1事实上是分作三个部分:mp1.1,mp1.2和mp1.3.

  mp1.1比较简单,只是做一些环境准备的工作,熟悉一下cool语言特性以及cool-support库代码.

  mp1.2是使用flex,完成一个cool的词法分析器(lexer),生成token序列,并做一些简单的错误处理

  mp1.3则是利用bison完成一个cool的语法分析器(parser),为对应的token序列生成AST,并作简单的错误恢复.

  总的来说,mp1的任务是完成对cool语言分析的一个完整前端(lexer+parser)

* 核心问题&设计&实现

  mp1.1由于是属于阅读实验,就不存在设计等方面的问题了,下面分别针对mp1.2和1.3说明一下:

  * mp1.2

    对于mp1.2,因为使用的工具是flex,所以最核心也是最基本的问题自然是flex的使用.flex文件是分为三部分,用%%分割开,要填充的主要是中间第二部分的内容,在其中定义正则表达式,并写明匹配规则以返回token流.原本的代码已经给出了一个基本框架,可以参照基本框架来完成.在写代码时还要注意理解用到的头文件,cool-parse.h等,其中有很多定义是需要用到的.

    整体的设计思路,首先参考cool-manual第10节词法结构的内容,了解cool的词法元素都有哪些,并为这些词法元素分别定义相应的正规表达式进行匹配,在匹配规则中返回对应的token记号.要处理的主要有int,objid,typeid,string,各种关键字等.同时还要注意识别处理注释和空格,对其只是匹配但不返回.

    另外还要完成的一件事是填充stringtable,因为为了节省空间而设置了stringtable这一机制.其中包括三个table,分别是整型,字符串和标识符的,在分析时还要把这3个table填好.

    在实现时,首先要写出各词法元素的正则表达式,这一点在cool manual中都描述得比较清楚,所以没有太大困难.之后就要对每个正则表达式定义匹配后的动作.首先最基本的是return对应的token值,另外除了各种关键字之外基本都还要有一些其他的操作,比如如果是bool常量要指明值是true还是false,是整形时要填充对应的stringtable,出错时要报错等.这些操作基本都是通过yylval这个变量来实现,这是一个枚举变量,取不同类型的值时可进行不同的操作,这里用到的主要是Symbol,Boolean和error_msg.

    实现时的一个难点是string和comment的分析,这里不能只使用简单的正规表达式匹配,需要用到flex的start condition功能,在gitbook中有说明.事实上这个功能类似于有限状态机,借助它才能完成对string和comment的分析.

    另外还要实现错误处理,实验要求中说明了要处理的错误类型,这里错误处理的基本思路是为错误情况也定义对应的正则表达式去匹配,然后根据错误处理的要求在匹配进行相应操作.

  * mp1.3

    对于mp1.3,其难度相对于1.2有所提升.这次使用的工具是bison,所以最核心和基本的问题与mp1.2类似,就是bison的使用. bison主要是通过定义产生式来定义文法,接受token序列,来进行语法分析,这里在语法分析时要完成的工作就是构建对应的AST.构建AST要使用cool-tree.h,要了解各种节点类的构造方法,层次关系和接口,这些内容需要参考cool support手册的第6节.而定义语法时要参考cool manual中的第12节figure1,其中基本详细地给出了cool的语法规则,都是现成的产生式,其中语法的终结符就是词法分析器产生的各种token.

    mp1.3的设计思想:首先,按照cool手册中给出的语法规则,定义正确的文法.之后参照AST各个节点类的构造函数的使用方法,对不同的情况利用对应的构造函数构造对应的AST节点.其中在定义文法时,虽然手册中已经基本给出文法,但事实上自己还是要进行改写,增加一些产生式的,比如表示let型表达式就需要用到自己定义的产生式. 之后还要进行错误恢复,错误恢复的基本思路是利用bison的error关键字,为要恢复的错误情况定义对应的产生式,使用yyerrok等进行错误恢复.

    具体实现时,多数产生式直接按照cool手册写即可,只有let表达式需要自己改写.因为let表达式对应的ast节点就是递归表示的,所以也是通过递归的产生式来分析let表达式.这里我是另外定义了一个非终结符let_sub来表示.另外还要自己改写的就是多个feature,expr等,需要定义类似feature_list这样的非终结符来表示.在构造各ast节点时,只要充分理解构造函数的用法,事实上并不是太困难.

    实现中一个比较主要的问题是移进规约冲突的解决.例如各种算数表达式,使用简单的文法表示的话会有二义性,产生很多冲突.在解决时一个常用的方法是利用bison的优先级机制,即为各个运算符(token)定义优先级和结合性,以此可以很容易地避免大部分冲突.如果优先级解决不了的冲突只能通过修改文法解决,不过在本次实验中并没有遇到需要修改文法解决的冲突.具体来说要处理的冲突主要有两类,一是各种运算符带来的冲突,二是let结构带来的冲突. 第一类利用优先级很好解决,第二类也是利用优先级机制,把 IN的优先级设为最低来解决,这在提交的answers.txt中也有说明.

    实现上最后的问题就是错误恢复,这里也是我感觉最有难度的部分,因为bison的error机制似乎不是很好理解,而如果不能透彻理解的话,就无法为错误情况定义恰当的产生式,也就无法很好地进行错误恢复.基本思路就是利用error为错误情况也定义相应产生式,匹配到时利用yyerrok等函数进行错误恢复.

    ​

    ​


* 遇到的问题&解决对策

  * mp1.2

    1.2中遇到的问题其实不是太大,主要的困难还是在于理解框架代码,这方面是比较耗时间的.对这次实验,一旦能够上手取做了,事实上并没有遇到太大的问题。我也没有遇到真正值得一说的问题,或者也许是时间太久远了忘掉了,总之对于这个实验暂时没有什么值得一提的问题.不过上交后助教的反馈里发现我在定义的时候忘掉了一个运算符,标识符的定义里忘了包含数字,并且在填inttable的时候直接把数字用atoi转成了int,实际上应该不处理.这都是一些小问题,在助教反馈后立即进行了改正.

  * mp1.3

    mp1.3中遇到的问题主要是在于错误恢复上,事实上对于正确的情况,也没有遇到令人印象深刻的值得一体的问题(也或许是想不起来了?).主要的问题都在于如何写出正确的文法,而由于cool手册给出了详细的参考,所以难度不是太大,这里可能值得一说的也就是let表达式的表达了,当时想了一会才想清楚怎么处理,但把文法写出来之后就没有发现什么问题.

    主要遇到的问题在于错误恢复上,因为正如之前所说,要做好错误恢复需要透彻地理解bison的error关键字的用法.但自己当时在做错误恢复时,感觉一直对error的机制似懂非懂,加上时间紧迫,所以为错误恢复写出的产生式也是很不简洁...甚至在ddl快到时还发现有bug,但是已经来不及改了.最后错误恢复几乎就只做了基本的要求,而且甚至基本的要求都没有做好,还有bug.更不要说扩展,几乎就没怎么做... 至于解决的对策,事实上这个问题也不能算完全解决了,当时被这个问题弄得头昏脑涨,push掉之后简直一眼都不想再看了...如果说要解决的话,也只能是认认真真看相关的文档说明了,把error的机制搞清楚了

* 参考文献

  flex与bison中文版

  cool manual 以及A Tour of the Cool Support Code

  bison和flex的官方手册

  以及不计其数的网上各种博客文章...(csdn之类的)



## MP2

- 总述
- 遇到的问题&解决对策
- 核心问题&设计&实现
- 参考文献

