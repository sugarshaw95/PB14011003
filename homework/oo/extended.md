

## oo拓展

* 对于类成员,对于数据成员(域)而言,其名字在反汇编代码中似乎并不能找到,应该就只是简单的内存偏移而已.

  而对于方法成员而言,经自己的多次测试,其在反汇编代码中的命名规则大概如下:

  "_ZNx(x为某个整数,似乎是按顺序的但也不是严格的按照1,2,3,4,5...这样排列)" +类名+整数y(y的分布规律与N后面的整数x类似)+方法名+"E"+参数个数个i,例如6个参数即为6个i,如果无参数则为v) 

  例如,类A的名为disp1,没有参数的成员方法在反汇编中的名字即为_ZN1A5disp1Ev

  而对于类的构造函数,命名规则大概相似,但也有一些区别,是这样的形式:

  "_ZNx(x为某正整数)+类名+"C1"+"E"+参数个数个i,无参数为v".

  区别在于类名后面没有整数,方法名被C1取代(C或许是constructor的意思?).

  例如,类A的有一个参数的构造函数在反汇编中名字为_ZN1AC1Ei

  另外,从地址上来看,类成员们是顺序存储的,例如类A的各个方法成员的地址顺序排列,之后是类B的各个方法成员,以此类推这样.

  ​

* 在动态链接生成的可执行文件的反汇编代码中,printf变成了printf@plt ,而cout由于似乎输出的内容类型不一样时(例如int和字符串)时调用的过程也不一样,所以没有一个统一的名字对应,不过似乎都是类似_ZNSolsE xxx@plt这样的命名.但事实上对应的命名规则不是重点.重要的是,它们都放在plt这个section中.经调研,plt即Procedure Linkage Table的缩写,即过程连接表,里面存的是动态链接库的函数表地址,函数调用时会跳到plt段中相应地址.在plt中,又会引用plt.got段中存储的函数的绝对地址,来将控制转移到实际的函数处.所以说plt中printf和cout对应的地址处并没有实际要执行的代码,只是寻址和跳转,使得最终能够跳转到实际函数处而已.

* 使用静态链接方式重新得到的oohw1对应的反汇编代码中,事实上包括了全部的<iostream>和<stdio.h>库.代码量非常庞大,有几十万行.所以说printf和cout自然也包括其中.这时printf和cout对应的位置不在plt段中,而是在text段中,也就是真正的代码段中. printf和cout在反汇编码中对应的位置也都是真正要执行的代码,也就是printf和cout真正的具体实现,而不是像动态链接一样只是进行跳转,因为静态链接事实上是把程序用到的库独享一份而不是共享公共的库文件,所以像printf和cout这样的外部函数在静态链接的反汇编代码中对应的内容也自然与动态链接完全不一样.

* 总结:

  面向对象语言中,类成员被编译时存储大体是按照顺序存储的,方法成员在反汇编代码中按照某种可循的规律命名,其中含有类名与方法名等特征,便于寻找.而数据成员在反汇编代码中并没有特别地为其命名,应该只是留出了相应的存储空间.

  动态链接产生的反汇编代码中,调用的外部库函数在其中并不对应具体的函数执行代码,而是利用plt段存储的函数表地址跳转到最终的函数执行位置(不在反汇编代码中).而静态链接中是反汇编代码是完整包含所使用的外部库的,代码量很庞大,所以调用外部的函数在其中直接对应text段中具体的可执行代码,而不是利用plt段那样的机制去跳转.因为单独保存了一份所用的库,所以静态链接生成的可执行文件也比动态链接大很多.

  p.s. 测试过程中看的反汇编码主要是写的比较简单的test文件的反汇编码,因为oohw比较复杂,反汇编码也比较长,不易观察.

  ​

